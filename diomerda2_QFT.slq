
//MAIN
def main(){
 
    //CIAO SVRIVI L'INPUT QUA DIPIERRO GRAZZZZIE RAGAZZI
    input := 3 ;    
    input_2 := 2  : int[4] ;  //qubit interi [][][][]
    //INPUT COME ARRAY DI QUBIT
    œà := input as int[4] ;

    //QFT
    output_qft := QFT(œà);
    
    //EVOLVE_QFT
    output_qft := EVOLVE_QFT(output_qft, input_2);


    //INVERSE QFT
    output_qft:=reverse(QFT[4])(output_qft);

    return(output_qft);
	//MISURA PER TORNARE ALL'ORIGINALE

}



//QFT
def QFT[n:!‚Ñï](œà: int[n])mfree: int[n]{
    for k in [0..n div 2){
        (œà[k],œà[n-k-1]) := (œà[n-k-1],œà[k]);
    }
                                        
    for l in (n..0] {        
        œà[l] := H(œà[l]) ;        //parto dall'ultimo e gli applico hadamard
        for i in [0..l) { 
            A:=œà[l-i-1]:ùîπ;         //
            if A{
                œà[l]:=rotZ(œÄ/(2^(i+1)),œà[l]);
            }
           // measure(A);

        }
    }

    return( œà ) ;
} 



def EVOLVE_QFT[n:!‚Ñï](A: int[n], B:int[n] ): int[n]{
    for k in [0..n div 2){
        (B[k],B[n-k-1]) := (B[n-k-1],B[k]);
    }
    for l in (n..0]{
        for i in [0..l+1){
            if (l-i)<=n-1{
                if B[l-i] {
                    rotZ(œÄ/(2^(i)), A[l]);
                }
            }
        }
    }
    m:=measure(B);
    return(A);


}

def REV_QFT[n:!‚Ñï](œà: int[n]): int[n]{
        for l in [0..n+1) {
         for i in [0..l) {          
            if œà[i] && œà[l]{
                phase(-œÄ/(2^(l-i)));
            }
        }
        œà[l] := H(œà[l]) ;

              
           
    }

    return (œà);
}



/*********************************/
/*
  qc.h(reg[n])    
    for i in range(0, n):
        #cp(theta, control_qubit, target_qubit[, ‚Ä¶])
        qc.cp(pie/float(2**(i+1)), reg[n-(i+1)], reg[n])
*/        

/***********************************/

/*
def EVOLVE_QFT[n:!‚Ñï](œà: int[n] )mfree: int[n]{

    b := 5:int[8] ;

     for k in [0..n div 2){
        (b[k],b[n-k-1]) := (b[n-k-1],b[k]);
    }


    for k in [0..n){
        œà[k] := H(œà[k]);
        for l in [k+1..n){
            if œà[l] && œà[k]{
                phase(2*œÄ * 2^(k-l-1));
            }
        }
    }
        
    return(  œà )  ;
} 
*/

/***********************************/
/*
 l = len(reg_b)
    for i in range(n+1):
        if (n - i) > l - 1:
            pass
        else:
            #cp(theta, control_qubit, target_qubit[, ...])
            qc.cp(pie/float(2**(i)), reg_b[n-i], reg_a[n])
*/
/***********************************/














// Phase Estimation algorithm
/*
import qft;

def phaseEstimation[k:!‚Ñï](
    U:int[k] !->mfree int[k],
    u:int[k], 
    precision:!‚Ñï) 
    {

    ancilla := 0:int[precision];
    for i in [0..precision) { ancilla[i] := H(ancilla[i]); }

    for i in [0..precision) { 
        if ancilla[i] {
            for l in [0..2^i) {
                u := U(u);
            }
        }
    }

    ancilla := reverse(QFT[precision])(ancilla);
    result := measure(ancilla);
    measure(u);
    return result;
}
*/


